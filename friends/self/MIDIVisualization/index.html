<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Midi可视化</title>

	<script type="text/javascript" src="./node_modules/Tone.js"></script>
	<script type="text/javascript" src="./node_modules/Midi.js"></script>
	<script src="./node_modules/pixi.js"></script>
</head>
<body>
	<input type="file" id="file">
	<input type="button" id="play" value="播放"/>
	
<script>
	const Application = PIXI.Application;  // 应用类，快速创建PIXI应用
    const Sprite = PIXI.Sprite;            // 精灵类
    const Graphics = PIXI.Graphics;        // 图形类
    // 创建应用程序并挂载
    const pixi = new Application({
      width: 1000,
      height: 600,
      backgroundColor: 0x000000
    })
    // pixi.view 代表画布，是一个canvas元素
    document.body.appendChild(pixi.view);

	const config = {
		  speed: 1,
		  leftColor: 0xFF69B4,
		  rightColor: 0x00BFFF,
		  color1: 0x66A9C9,
		  color2: 0xF0C9CF,
		  color3: 0xE2C17C,
		  color4: 0x363433,
		  color5: 0xFF4500,
		}
	// 定义灯光类作为音符的可视化
	class Light extends Graphics {
	  constructor(color, height, x) {
		super();
		this.beginFill(color);
		this.drawRect(x, 600, 10, height);
		this.endFill();
		// pixijs的定时器，可以实现每帧执行一次，并且十分稳定
		pixi.ticker.add(() => {
		  this.y -= config.speed * 5;
		});
	  }
	}
	// pixi.stage 代表舞台，所有的物体必须挂载在舞台上才可以显示。

    const input = document.querySelector('#file');
    input.addEventListener('change', (e) => {
      console.log(e.target.files[0]);
	  parseMidi(e.target.files[0]);
    })
	
    // 读取midi文件
    function parseMidi(file) {
      // 创建文件读取器
      const reader = new FileReader();
      // 读取文件
      reader.readAsArrayBuffer(file);
      // 文件读取完成后将文件转化为json对象
      reader.addEventListener('load', (e) => {
        currentMidi = new Midi(e.target.result);
        console.log(currentMidi);
      })
    }
	
	play.addEventListener('click', (e) => {
      console.log(currentMidi);
      // 如果未加载midi文件
      if(!currentMidi) {
        alert('未加载文件');
        return;
      }

      const now = Tone.now() + 0.5; // 获取当前时间
      const synths = [];            // 存储合成器
      // 遍历midi文件中的轨道
      currentMidi.tracks.forEach(track => {
        // 创建合成器作为音轨并连接至出口，音色使用Tonejs的默认音色
        const synth = new Tone.PolySynth(Tone.Synth, {
					envelope: {
            // 声音的生命周期：按下按键 - 渐入 - 攻击阶段 - 衰减阶段 - 衰减结束 - 松开按键 - 声音消逝
						attack: 0.02,     // 渐入时间
						decay: 0.1,       // 攻击阶段（最大音量）持续时间
						sustain: 0.3,     // 衰减结束后的最小声音
						release: 1,       // 从松开按键到声音彻底消失所需的时间
					},
				}).toDestination();
		// 将合成器存储起来，为之后停止播放的功能留下接口。
        synths.push(synth);

        // 遍历轨道中的每个音符
        track.notes.forEach(note => {
          // 合成器发声
          synth.triggerAttackRelease(
						note.name,         // 音名
						note.duration,     // 持续时间
						note.time + now,   // 开始发声时间
						note.velocity      // 音量
					);
					
			// 在播放按钮的事件中，遍历音符时，创建音频调度，实现音画同步
			Tone.Transport.schedule((time) => {
				// 根据音调划分颜色，（其实应该根据轨道来划分的）
				var color = config.color1;
				if(note.midi < 15) {
					color = config.color1;
				} else if (note.midi < 30){					
					color = config.color2;
				} else if (note.midi < 45){
					color = config.color3;
				} else if (note.midi < 60){
					color = config.color4;
				} else {
					color = config.color5;
				}
				color = '0x'+ Math.random().toString(16).substr(2,6);
				pixi.stage.addChild(new Light(color, note.duration * 150 * config.speed, (note.midi - 20) * 10))
				
			}, note.time + now);

			// 在代码最外层设置音频调度的模式，并启动音频调度。
			Tone.context.latencyHint = 'fastest';
			Tone.Transport.start();

        });
      });
    })
	
	
	
</script>
</body>
</html>
